<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言十大排序算法总结</title>
      <link href="/2024/03/13/C%E8%AF%AD%E8%A8%80%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/13/C%E8%AF%AD%E8%A8%80%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序">插入排序</h1><blockquote><p>基本思想是每次将一个待排序的记录按其关键字大小插入前面已经排好序的子序列，直到全部记录插入完成。</p></blockquote><h2 id="直接插入排序">1.直接插入排序</h2><h3 id="代码实现">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 依次将arr[1, ..., arrSize - 1]插入到前面已经排序好的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123; <span class="comment">// 若arr[i]小于前驱，需要将其插入前面已经排序好的子序列</span></span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="comment">// 从后往前查找待插入位置, 终止条件是，arr[j] &lt;= temp;</span></span><br><span class="line">            <span class="type">int</span>  j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">// 后移</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// arr[j] &lt;= temp; j + 1是插入位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析</h3><ul><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(n^2)\)</span>；<ul><li>向有序子表中逐个插入元素的操作进行了 <span class="math inline">\(n -1\)</span> 趟，每趟操作都分为比较关键字和移动元素。</li><li><strong>最好的情况</strong>是元素有序，此时每插入一个元素，都只需比较一次而不用移动元素，时间复杂度为$ O(n) $;</li><li><strong>最坏的情况</strong>是元素逆序，总的比较次数为 $(1 + 2 + 3 +··· + n - 1) $ ，总的移动次数为 <span class="math inline">\((1 + 2  +··· + n - 1 + 2)\)</span>;</li></ul></li><li><strong>空间复杂度：</strong>$ O(1)$；<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性</strong>：稳定<ul><li>由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况。</li></ul></li></ul><h2 id="折半插入排序">2.折半插入排序</h2><h3 id="代码实现-1">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与直接插入唯一不同在于查找插入位置时是使用折半查找</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 依次将arr[1, ..., arrSize - 1]插入到前面已经排序好的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i]; <span class="comment">// 将当前元素保存</span></span><br><span class="line">        <span class="comment">// 在前面子序列中折半查找插入位置</span></span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; arr[mid]) <span class="comment">//查左半子表</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 查右半子表</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// low是插入位置, 或者high + 1;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= low; --j) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1">复杂度分析</h3><ul><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(n^2)\)</span>；<ul><li>折半插入排序仅减少了比较元素的次数，比较次数约为 <spanclass="math inline">\((nlog_2 n)\)</span></li><li>比较次数与待排序表的初始状态无关，仅取决于表中的元素个数 <spanclass="math inline">\(n\)</span>;</li></ul></li><li><strong>空间复杂度：</strong>$ O(1)$；<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性</strong>：稳定</li></ul><h2 id="希尔排序">3.希尔排序</h2><blockquote><p>先将待排序表分割成若干形如 $ L[i, i + d, i + 2d, ··· , i + kd]$ 的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。</p></blockquote><h3 id="代码实现-2">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// d1 = n / 2, d(i + 1) = d1 / 2;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> dk = arrSize / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk /= <span class="number">2</span>) &#123; <span class="comment">// 可以将dk理解为步长，dk = 1时，退化为直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = dk; i &lt; arrSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i - dk]) &#123; <span class="comment">// 需要将 arr[i] 插入有序增量子表中</span></span><br><span class="line">                <span class="type">int</span> temp = arr[i];</span><br><span class="line">                <span class="type">int</span> j = i - dk;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                    arr[j + dk] = arr[j];</span><br><span class="line">                    j -= dk;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 退出循环后，arr[j] &lt;= temp, 显然 j + dk 是插入位置</span></span><br><span class="line">                arr[j + dk] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2">复杂度分析</h3><ul><li><strong>时间复杂度：</strong><ul><li>希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难</li><li>当 <span class="math inline">\(n\)</span>在某个特定范围内，希尔排序的时间复杂度约为 <spanclass="math inline">\(O(n^{1.3})\)</span>;</li><li>最坏情况下希尔排序的时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span>;</li></ul></li><li><strong>空间复杂度：</strong><spanclass="math inline">\(O(1)\)</span>;<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性：</strong>不稳定<ul><li>当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序。</li></ul></li></ul><h1 id="交换排序">交换排序</h1><blockquote><p>所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。</p></blockquote><h2 id="冒泡排序">4.冒泡排序</h2><h3 id="代码实现-3">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本思想：从前往后两两比较相邻元素的值，若为逆序，则交换他们，直到序列比较完</span></span><br><span class="line"><span class="comment">// 上述是第一趟冒泡，结果是将最大的元素交换到最后一个</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize - <span class="number">1</span>; i++) &#123; <span class="comment">// 无须和自己比较，所以趟数为 arrSize - 1;</span></span><br><span class="line">        <span class="type">int</span> swapflag = <span class="number">0</span>;<span class="comment">// 表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arrSize - <span class="number">1</span> - i; j++) &#123; <span class="comment">// arrSize - 1 - i 是因为每一趟就会少一个</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">/* 交换 */</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                swapflag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本趟遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (swapflag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后往前</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort2</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> swapflag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// j 从后往前，第i趟说明第i个元素确定好顺序了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arrSize - <span class="number">1</span>; j &gt; i; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">/* 交换 */</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                swapflag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (swapflag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3">复杂度分析</h3><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(n^2)\)</span>;<ul><li>最好情况下时间复杂度为 <span class="math inline">\(O(n)\)</span>;<ul><li>初始序列有序，第一趟冒泡排序后直接跳出循环。此时比较次数为 <spanclass="math inline">\(n - 1\)</span>，移动次数为 <spanclass="math inline">\(0\)</span>;</li></ul></li><li>最坏情况下时间复杂度为 <span class="math inline">\(O(n^2)\)</span> ;<ul><li>初始序列逆序，要进行 <span class="math inline">\((n - 1)\)</span>趟冒泡。第 <span class="math inline">\(i\)</span> 趟要进行 <spanclass="math inline">\(n - i\)</span> 次比较，移动次数为 <spanclass="math inline">\(3(n - i)\)</span> ;</li></ul></li></ul></li><li><strong>空间复杂度：</strong> <spanclass="math inline">\(O(1)\)</span>;<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性：</strong>稳定</li></ul><h2 id="快速排序">5.快速排序</h2><h3 id="代码实现-4">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 假设枢轴元素为第一个</span></span><br><span class="line">    <span class="type">int</span> pivot = arr[low];</span><br><span class="line">    <span class="comment">// 高低指针向中心靠拢</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 高指针寻找第一个比枢轴元素小的</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--;</span><br><span class="line">        arr[low] = arr[high];   <span class="comment">// 将其移动至arr[low]</span></span><br><span class="line">        <span class="comment">// 低指针寻找第一个比枢轴元素大的</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++;</span><br><span class="line">        arr[high] = arr[low];   <span class="comment">// 将其移动至arr[high]</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="comment">// 返回的是确定位置的元素下标  </span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件 </span></span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 确定位置的元素下标 </span></span><br><span class="line">    <span class="type">int</span> mid = partition(arr, low, high);</span><br><span class="line">    <span class="comment">// 左边递归排序 </span></span><br><span class="line">    quickSort(arr, low, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 右边递归排序 </span></span><br><span class="line">    quickSort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-4">复杂度分析</h3><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(log_2n)\)</span>;<ul><li>快速排序的运行时间与划分是否对称有关。</li><li>最坏情况：<span class="math inline">\(O(n^2)\)</span>;<ul><li>两个区域分别包括 <span class="math inline">\(n - 1\)</span> 和 <spanclass="math inline">\(0\)</span> 个元素时，即序列开始时便逆序</li></ul></li><li>最好情况：<span class="math inline">\(O(nlog_2n)\)</span>;<ul><li>尽可能地划分两个左右序列</li></ul></li></ul></li><li><strong>空间复杂度：</strong><spanclass="math inline">\(O(nlog_2n)\)</span>;<ul><li>由于快排是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大深度一致</li><li>最好的情况：<span class="math inline">\(O(log_2n)\)</span>;</li><li>最坏的情况：<span class="math inline">\(O(n)\)</span>;<ul><li>因为要进行 <span class="math inline">\(n - 1\)</span>次递归调用</li></ul></li></ul></li><li><strong>算法稳定性：</strong>不稳定<ul><li>在划分算法中，若右端区间有两个关键字相同，且均小于枢轴元素，则在交换到左端区间后，它们的相对位置会发生变化</li></ul></li></ul><h1 id="选择排序">选择排序</h1><blockquote><p>选择排序的基本思想是：每一趟（如第 <spanclass="math inline">\(i\)</span> 趟）在后面 <spanclass="math inline">\(n - i + 1(i = 1, 2, ··· ,n - 1)\)</span>个待排序元素中选取关键字最小的元素，作为有序子序列的第 <spanclass="math inline">\(i\)</span> 个元素，直到第 <spanclass="math inline">\(n - 1\)</span>趟排序做完，待排序元素只剩下1个，就不再选了。</p></blockquote><h2 id="简单选择排序">6.简单选择排序</h2><h3 id="代码实现-5">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法思想：假设排序表为L[1,...,n]，第i趟排序即从L[i,..,n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置</span></span><br><span class="line"><span class="comment">// 这样经过 n - 1趟排序就可以使得整个排序表有序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arrSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// minIndex 为最小元素下标</span></span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-5">复杂度分析</h3><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(n^2)\)</span>;<ul><li>主要分为比较次数和移动次数</li><li>最坏情况下，比较次数为<span class="math inline">\((1 + 2 + ··· + n -1)\)</span>, 移动次数为<span class="math inline">\(3(n -1)\)</span>;</li><li>最好情况下，比较次数为<span class="math inline">\((1 + 2 + ··· + n -1)\)</span>, 移动次数为 <span class="math inline">\(0\)</span>;</li></ul></li><li><strong>空间复杂度：</strong> <spanclass="math inline">\(O(1)\)</span>;<ul><li>仅使用常数个辅助单元</li></ul></li><li><strong>算法稳定性：</strong>不稳定<ul><li>{2，<strong>2</strong>， 1} 经过一趟排序后变为{1，<strong>2</strong>， 2};</li></ul></li></ul><h2 id="堆排序">7.堆排序</h2><h3 id="代码实现-6">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先将元素建成大根堆，此时堆顶元素就是最大值。</span></span><br><span class="line"><span class="comment"> * 输出堆顶元素后，通常将堆底元素送入堆顶，此时根节点不满足大根堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大根堆的性质。</span></span><br><span class="line"><span class="comment"> * 再输出堆顶元素，如此重复，直至堆中仅剩下一个元素为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整以k为根节点的堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjustDown</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 先将根节点的值保存一下 </span></span><br><span class="line">    <span class="type">int</span> tmp = arr[k];</span><br><span class="line">    <span class="comment">// 2 * k + 1: k节点的左节点</span></span><br><span class="line">    <span class="comment">// 2 * k + 2: k节点的右节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * k + <span class="number">1</span>; i &lt; arrSize; i = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// i + 1 &lt; arrSize 确保右节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; arrSize &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>]) <span class="comment">// 左子节点 &lt; 右子节点</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">// i始终指向值最大的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= arr[i]) <span class="comment">// k节点值 &gt;= 子节点，满足大根堆性质</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            arr[k] = arr[i];</span><br><span class="line">            k = i; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[k] = tmp;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/* 建立小跟堆 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 最后一个父节点 </span></span><br><span class="line">    <span class="comment">// arrSize为元素个数, -1 是因为下标从0开始</span></span><br><span class="line">    <span class="type">int</span> i = arrSize / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjustDown(arr, arrSize, i); <span class="comment">// 调整以i为父节点的堆</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapsort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 建立大根堆</span></span><br><span class="line">    buildMaxHeap(arr, arrSize);</span><br><span class="line">    <span class="comment">// 2. 从最后一个元素开始，与堆顶元素进行交换，直到只剩下一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[<span class="number">0</span>]; </span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="comment">// 交换完成，调整大根堆，此时堆的长度为i</span></span><br><span class="line">        adjustDown(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="复杂度分析-6">复杂度分析</h3><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(nlog_2n)\)</span>;<ul><li>分为建立大根堆和调整堆<ul><li>在建n个元素的堆时，时间复杂度为 <spanclass="math inline">\(O(n)\)</span>;</li><li>需要进行 <span class="math inline">\(n - 1\)</span>次堆调整，每次调整的时间复杂度为 <spanclass="math inline">\(O(h)\)</span></li></ul></li></ul></li><li><strong>空间复杂度：</strong><spanclass="math inline">\(O(1)\)</span>;<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性：</strong>不稳定</li></ul><h1 id="归并排序">8.归并排序</h1><h2 id="代码实现-7">代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假定待排序表含有n个记录，则可将其视为n个有序的子表，每个子表的长度为1，然后两两归并，等到 n/2(向上取整) 个长度为2或1的有序表；</span></span><br><span class="line"><span class="comment"> * 继续两两归并······</span></span><br><span class="line"><span class="comment"> * 如此重复，直至合并成一个长度为n的有序表为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将前后相邻的两个有序表归并为一个有序表</span></span><br><span class="line"><span class="comment">// arr[low, mid], arr[mid + 1, high];</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 开辟一个临时数组，tmp[low, high]</span></span><br><span class="line">    <span class="type">int</span> *tmp = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (high - low + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">// tmp[]的下标</span></span><br><span class="line">    <span class="comment">// 从两个有序表第一个元素开始往后遍历，将小元素放入tmp中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前面有序表未放完</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = arr[i++];</span><br><span class="line">    <span class="comment">// 后面有序表未放完</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        tmp[k++] = arr[j++];</span><br><span class="line">    <span class="comment">// 将tmp元素赋值到arr中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        arr[low + i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mergesort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    mergesort(arr, left, mid);</span><br><span class="line">    mergesort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(arr, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-7">复杂度分析</h2><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(nlog_2n)\)</span><ul><li>每趟归并的时间复杂度为 <spanclass="math inline">\(O(n)\)</span>，需要进行 <spanclass="math inline">\(log_2n(向上取整)\)</span> 趟归并</li></ul></li><li><strong>空间复杂度：</strong> <spanclass="math inline">\(O(n)\)</span>;<ul><li>merge()操作中，辅助空间刚好为<spanclass="math inline">\(n\)</span>个单元</li></ul></li><li><strong>算法稳定性：</strong> 稳定</li></ul><h1 id="计数排序">9. 计数排序</h1><blockquote><p>主要思想：开辟一个长为 maxVal - minVal +1的计数数组，然后遍历一遍原数组，将元素值-minVal作为计数数组的索引，值则自增。</p><p>此时计数数组中不为0的元素值为原数组中元素值等于索引的个数。遍历计数数组，遇到不为0的元素，反写回原数组。</p></blockquote><h2 id="代码实现-8">代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不稳定法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化最大值和最小值为首元素</span></span><br><span class="line">    <span class="type">int</span> maxVal = arr[<span class="number">0</span>], minVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxVal)</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; minVal)</span><br><span class="line">            minVal = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 maxVal, minVal分别为最大值和最小值</span></span><br><span class="line">    <span class="comment">// 创建一个计数数组, 长度为maxVal - minVal + 1;</span></span><br><span class="line">    <span class="type">int</span> countArrSize = maxVal - minVal + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *countArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (countArrSize));</span><br><span class="line">    <span class="comment">// 将计数数组初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; countArrSize; i++)</span><br><span class="line">        countArr[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将原数组中的值减去最小值，将其作为索引，存入计数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        countArr[arr[i] - minVal]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历计数数组，根据元素个数还原</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; countArrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (countArr[i]) &#123; <span class="comment">// count数组中还有计数</span></span><br><span class="line">            arr[j++] = i + minVal; <span class="comment">// 要加上最小值，还原    </span></span><br><span class="line">            countArr[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(countArr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 稳定法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countSort2</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取排序数组的最大元素</span></span><br><span class="line">    <span class="type">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取排序数组的最小元素</span></span><br><span class="line">    <span class="type">int</span> minVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxVal)</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; minVal)</span><br><span class="line">            minVal = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数数组的长度</span></span><br><span class="line">    <span class="type">int</span> countArrSize = maxVal - minVal + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建一个计数数组</span></span><br><span class="line">    <span class="type">int</span> *countArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * countArrSize);</span><br><span class="line">    <span class="comment">// 初始化为0</span></span><br><span class="line">    <span class="built_in">memset</span>(countArr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * countArrSize);</span><br><span class="line">    <span class="comment">// 计数, 统计每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        countArr[arr[i] - minVal]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累计计数，计算每个元素在排序后数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; countArrSize; i++) &#123;</span><br><span class="line">        countArr[i] += countArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序：根据累计计数数组将元素放置到正确的位置</span></span><br><span class="line">    <span class="type">int</span> *result = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * arrSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        result[countArr[arr[i] - minVal] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        countArr[arr[i] - minVal]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制到原空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-8">复杂度分析</h2><ul><li><strong>时间复杂度：</strong> $O(n + k) <spanclass="math inline">\(，\)</span>k$ 为整数范围<ul><li>最后的两层循环，最外层执行的次数为 <spanclass="math inline">\(k\)</span>, 最里层最终次数为<spanclass="math inline">\(n\)</span>, 因此总的次数是 <spanclass="math inline">\(n + k\)</span>;</li></ul></li><li><strong>空间复杂度：</strong><ul><li><span class="math inline">\(O(k)\)</span>，<spanclass="math inline">\(k\)</span>​ 为整数范围（不稳定算法）</li><li><span class="math inline">\(O(k + n)\)</span>, （稳定算法）</li></ul></li><li><strong>算法稳定性：</strong>稳定 / 不稳定</li></ul><h1 id="桶排序">10. 桶排序</h1><blockquote><p>主要思想就是：将要排序的数据分到几个有序的桶里，每个桶里的元素再单独进行排序。桶内排序完之后，再把每个桶里面的数据按照顺序依次取出，组成的序列就是排好序的序列。</p><p>要先确定好桶的个数和映射函数</p></blockquote><h2 id="代码实现-9">代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义桶的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 桶中元素个数</span></span><br><span class="line">    <span class="type">int</span>* values;    <span class="comment">// 桶中数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 桶排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bucketCount = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 创建桶数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> <span class="title">buckets</span>[<span class="title">bucketCount</span>];</span>   </span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        buckets[i].count = <span class="number">0</span>;</span><br><span class="line">        buckets[i].values = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据分散到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="type">int</span> bucketIndex = <span class="built_in">array</span>[i] / bucketCount;</span><br><span class="line">        buckets[bucketIndex].values[buckets[bucketIndex].count++] = <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 对每个桶中的数据进行排序</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (buckets[i].count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">// 使用简单的冒泡排序，实际中可以使用其他更高效的排序算法</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; buckets[i].count - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; buckets[i].count - j - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (buckets[i].values[k] &gt; buckets[i].values[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                         <span class="comment">// 交换桶中的元素</span></span><br><span class="line">                         <span class="type">int</span> temp = buckets[i].values[k];</span><br><span class="line">                         buckets[i].values[k] = buckets[i].values[k + <span class="number">1</span>];</span><br><span class="line">                         buckets[i].values[k + <span class="number">1</span>] = temp;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 合并所有桶的结果</span></span><br><span class="line">     <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; buckets[i].count; j++) &#123;</span><br><span class="line">             <span class="built_in">array</span>[index++] = buckets[i].values[j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 释放桶内存</span></span><br><span class="line">         <span class="built_in">free</span>(buckets[i].values);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-9">复杂度分析</h2><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(n)\)</span>​<ul><li>在均匀分布情况下，桶排序的平均时间复杂度接近线性</li></ul></li><li><strong>空间复杂度</strong>：较高，具体取决于桶的数量和分配的空间</li><li><strong>算法稳定性：</strong>取决于桶内排序的稳定性</li><li>桶排序仅适用于元素数据分布相对均匀且元素范围较小。</li></ul><h1 id="基数排序">11.基数排序</h1><blockquote><p>主要思想是：第一趟排序的基数为1，即根据个位数放入相应的桶中，然后再将按桶号将桶中元素分别放回原数组，完成一趟排序，此时个位数已经有序</p><p>第二趟排序的基数为10，即根据10位数放入相应的桶中，重复以上过程。</p><p>趟数为最大元素的数字个数。</p></blockquote><h2 id="代码实现-10">代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义十个桶 0...9</span></span><br><span class="line">    <span class="type">int</span> bucket[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// result 是答案数组</span></span><br><span class="line">    <span class="type">int</span> *result = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * arrSize);</span><br><span class="line">    <span class="comment">/* 1.求数组中最大元素 */</span></span><br><span class="line">    <span class="type">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxVal)</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 2.求最大元素数字个数 */</span></span><br><span class="line">    <span class="type">int</span> maxValCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxVal) &#123;</span><br><span class="line">        maxValCount += <span class="number">1</span>;</span><br><span class="line">        maxVal /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="type">int</span> base = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; maxValCount; k++) &#123;</span><br><span class="line">         <span class="comment">// 求每一个元素的base上数字，放入对应的桶里面</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">             bucket[(arr[i] / base) % <span class="number">10</span>]++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 计算累加和</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 根据桶数组，将元素放入原先数组中</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">             result[bucket[(arr[i] / base) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">             bucket[(arr[i] / base) % <span class="number">10</span>]--;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 将result数组元素复制到arr中，循环</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">             arr[i] = result[i];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 清空桶元素</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             bucket[i] = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// base乘以10，进入下一趟排序</span></span><br><span class="line">         base *= <span class="number">10</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-10">复杂度分析</h2><ul><li><strong>时间复杂度：</strong> <span class="math inline">\(O(d(n +r)\)</span><ul><li><span class="math inline">\(d\)</span> ——最大数字的位数，即循环的次数</li><li><span class="math inline">\(r\)</span> ——数字的基数，表明桶的个数</li></ul></li><li><strong>空间复杂度</strong>：<span class="math inline">\(O(n +r)\)</span></li><li><strong>算法稳定性：</strong>稳定</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 C 排序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Socket编程</title>
      <link href="/2023/10/01/Linux-Socket%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/10/01/Linux-Socket%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>linux c socket</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/30/hello-world/"/>
      <url>/2023/09/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
