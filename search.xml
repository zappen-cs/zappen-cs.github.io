<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>新增Linux系统调用——计算一个数的三次方</title>
      <link href="/2024/03/21/%E6%96%B0%E5%A2%9ELinux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9/"/>
      <url>/2024/03/21/%E6%96%B0%E5%A2%9ELinux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="新增linux系统调用">新增Linux系统调用</h1><blockquote><p>  起初看到这个实验，完全是一脸懵啊，后来再看，依旧是一脸懵啊，再后来，借鉴了网上大佬们的教程，以及一天的时间折腾，终于完成了该实验。只是可惜了自己的电脑，CPU以80℃的温度运行一整天，好想对电脑说一句，下辈子别摊上我这个主了，找个好人家！！！哈哈哈！！！  鉴于网上关于这方面的教程太过古老，以及教程过少，在此，记录一下，作为读者们的学习资料，也作为自己的学习笔记。</p></blockquote><hr /><p><strong>本文目录</strong></p><ul><li>实验内容及要求</li><li>实验步骤<ul><li>下载新内核</li><li>修改新内核</li><li>编译新内核</li></ul></li><li>实验测试</li><li>总结</li></ul><hr /><h2 id="一实验内容及要求">一、实验内容及要求</h2><p>要求：</p><ul><li>需要重新编译Linux内核；</li><li>增加一个Linux的系统调用；</li><li>另外写一个程序进行调用。</li></ul><p>功能：</p><p>  计算一个数字的三次方，并打印出来。</p><h2 id="二实验步骤">二、实验步骤</h2><p>  本篇教程所需的实验环境为VMware Workstation 16 Pro + Ubuntu 20.04。如果你的电脑不具备Linux环境，或者说并没有配置Ubuntu系统，可以参考博主之前的两篇文章——<ahref="https://blog.csdn.net/weixin_44191535/article/details/105150707">《VMware虚拟机安装Ubuntu》</a>、<ahref="https://blog.csdn.net/weixin_44191535/article/details/105151862">《VMware下Ubuntu的基本配置》</a>。</p><h3 id="查看内核版本">1.查看内核版本</h3><p>打开【<strong>终端</strong>】，输入 <strong>uname-r</strong>，查看当前操作系统的内核版本。 <imgsrc="https://img-blog.csdnimg.cn/2189fb059e2641a697faba596d7cf531.png#pic_center"alt="在这里插入图片描述" /> 此时我们看到的内核版本为<strong>5.15.0-75</strong> 。</p><h3 id="下载新内核">2.下载新内核</h3><p>  内核下载的官网为 <ahref="https://mirrors.edge.kernel.org/pub/linux/kernel/">https://mirrors.edge.kernel.org/pub/linux/kernel/</a>，选择需要下载的版本，下载即可。但是下载的速度真的如蜗牛爬一般啊，这里博主推荐使用国内镜像去下载，博主使用的是北京交通大学的开源镜像。<ahref="https://mirror.bjtu.edu.cn/kernel/linux/kernel/">(点击跳转）</a>  不建议使用最新的内核，建议使用老一点的内核，这样比较稳定些，不会因为内核的问题而导致编译出错。  博主选择的内核版本为 5.6.8。</p><p>在【<strong>终端</strong>】中输入 <strong>wgethttps://mirror.bjtu.edu.cn/kernel/linux/kernel/v5.x/linux-5.6.8.tar.xz</strong>，然后 <strong>回车</strong>。 <imgsrc="https://img-blog.csdnimg.cn/8e052699d9b5435c9fda228f11747603.png#pic_center"alt="在这里插入图片描述" />下载完成后，在主目录下便可以看到刚才下载的内核压缩包。 <imgsrc="https://img-blog.csdnimg.cn/3e9a9a69e5814b9394d676a014c1447f.png#pic_center"alt="在这里插入图片描述" /></p><p>### 3.解压内核压缩包</p><p>在【<strong>终端</strong>】中依次输入以下命令：</p><ul><li><strong>tar -Jxvf linux-5.6.8.tar.xz</strong> <imgsrc="https://img-blog.csdnimg.cn/266c11d2b002407c9f388917fd6513dd.png#pic_center"alt="在这里插入图片描述" /></li></ul><hr /><blockquote><p>下面的所有命令全在 <code>~/linux-5.6.8</code> 目录下执行。</p></blockquote><p>首先转到 <code>~/linux-5.6.8</code> 目录下在【<strong>终端</strong>】执行 <strong>cd linux-5.6.8/</strong> <imgsrc="https://img-blog.csdnimg.cn/ec9674b071f543ffaa3fb6ed22be01ea.png#pic_center"alt="在这里插入图片描述" /></p><h3 id="新增linux系统调用-1">4.新增Linux系统调用</h3><p>（1）添加调用函数<strong>声明</strong></p><p>【<strong>终端</strong>】输入 <strong>viminclude/linux/syscalls.h</strong> ，在 ==#endif== 前输入<code>asmlinkage long sys_cube(int num);</code> <imgsrc="https://img-blog.csdnimg.cn/8de671e4972c42bd942de430048e8982.png#pic_center"alt="在这里插入图片描述" /></p><p><strong>注：</strong>  执行完上面命令后，打开了一个头文件，此时vim处于命令模式，我们可以看见光标，但不可以编辑，移动光标到需要编辑的位置，按键盘上的【i】，进入编辑模式，待内容输入完成后，按【Esc】，切换至命令模式，此时输入【:wq】，即完成了保存退出操作。<imgsrc="https://img-blog.csdnimg.cn/0e1a34c4868a4464b889b1384c75c455.png#pic_center"alt="在这里插入图片描述" /></p><p>（2）添加调用函数<strong>定义</strong></p><p>【<strong>终端</strong>】输入 <strong>vim kernel/sys.c</strong>,在末尾 #endif 后输入如下函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(cube,<span class="type">int</span>,num)&#123;</span><br><span class="line">    <span class="type">int</span> result = num*num*num;</span><br><span class="line">    printk(<span class="string">&quot;The result is %d.\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://img-blog.csdnimg.cn/124e5994f2fe4947a1e9452e6c41766c.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure><imgsrc="https://img-blog.csdnimg.cn/b9e340a2c66442109e7734f03f31093f.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>（3）注册系统调用号</p><p>在【<strong>终端</strong>】输入 <strong>vimarch/x86/entry/syscalls/syscall_64.tbl</strong>，在syscall_64.tbl文件中添加如下内容： <imgsrc="https://img-blog.csdnimg.cn/cf6d30f4e06b45b491797d0eabeef64d.png#pic_center"alt="在这里插入图片描述" /></p><p><imgsrc="https://img-blog.csdnimg.cn/9b05341d21134b01bbfae135cdb25cb5.png#pic_center"alt="在这里插入图片描述" /> 此时添加的自定义函数对应的系统调用号是<strong>439</strong> 。</p><hr /><p>上面的过程已经添加了一个新的系统调用，下面的过程则是编译内核并安装新内核，可谓是本文的重点所在。</p><h3 id="安装编译内核所需的依赖包">5.安装编译内核所需的依赖包</h3><p>打开【<strong>终端</strong>】，依次输入下面命令：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt install make flex bison libssl-dev libelf-dev libncurses5-dev dwarves -y</span><br></pre></td></tr></table></figure><figure><imgsrc="https://img-blog.csdnimg.cn/370ccfbf6ba0474bb1674105243c7962.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="配置内核">6.配置内核</h3><p>（可选）【<strong>终端</strong>】输入 <strong>make mrproper</strong>，用来清除以前配置，若是第一次配置，则不需执行此命令，博主是第一次编译，因此不执行该条命令。</p><p>【<strong>终端</strong>】输入<strong>makemenuconfig</strong>，在跳出的界面中依次执行【Save】—&gt;【Ok】—&gt;【Exit】—&gt;【Exit】<imgsrc="https://img-blog.csdnimg.cn/34282d189ec24ce7bcae11bf6a2ef543.png#pic_center"alt="在这里插入图片描述" /></p><figure><imgsrc="https://img-blog.csdnimg.cn/d0d2d01b2ee44421bb6200dbef731b13.png#pic_center%20=800x"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure><imgsrc="https://img-blog.csdnimg.cn/6fac185f98e0480997cc10f5b676d48a.png#pic_center%20=800x"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure><imgsrc="https://img-blog.csdnimg.cn/52bd994e1e8e43029e171ae0a648eb98.png#pic_center%20=800x"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>​ <imgsrc="https://img-blog.csdnimg.cn/6f9e368e6eb044c6bb7f9a7d6e445dab.png#pic_center=8"alt="在这里插入图片描述" /></p><h3 id="编译">7.编译</h3><p>查看自己机器处理器的核数，可通过 <code>cat /proc/cpuinfo</code>来查看。 <imgsrc="https://img-blog.csdnimg.cn/8ac7dd8ede8c435faf83e482a69f92b8.png#pic_center"alt="在这里插入图片描述" />此处的<strong>processor</strong>后面的数字表示的是处理器编号，只需要查看最大编号便可知道处理器的核数了。或者打开虚拟机设置，可通过查看硬件配置来查看处理器的核数，此处为<strong>8</strong>。</p><figure><imgsrc="https://img-blog.csdnimg.cn/97c378e009864531b10dcba8564191d4.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>在【<strong>终端</strong>】中键入 <strong>make-jn</strong>（n个线程开始编译），因为本文机器的处理器核数为8，故博主这里的命令是<code>make -j8</code>随后就是漫长的等待了，等到地老天荒，哈哈哈哈，大概一小时左右！</p><p><imgsrc="https://img-blog.csdnimg.cn/397aa228dfb842859d71f611942dcb9e.png#pic_center"alt="在这里插入图片描述" /> 中途可能会报一些错误，我将其归纳在此，<ahref="#1">点击跳转</a>。</p><p>编译要结束时，如果看到下图所示的信息，说明你已经编译成功了，一定要看到此提示信息，因为有时候会内核编译停止，重启电脑后可能开不了机器。若没有看到此条信息，建议继续<code>make -j8</code>一下。 <imgsrc="https://img-blog.csdnimg.cn/3cf9dca86ff9490385006a5d3e5ee912.png#pic_center"alt="在这里插入图片描述" /></p><h3 id="安装编译好的模块">8.安装编译好的模块</h3><p>【<strong>终端</strong>】键入<strong>sudo makemodules_install</strong> 命令，完成模块的安装操作 <imgsrc="https://img-blog.csdnimg.cn/a62e51fbb9ce4ae19f8a1853a7032099.png#pic_center"alt="在这里插入图片描述" /></p><p>这个命令执行也需要一定的时间，耐心等待就好。</p><h3 id="安装内核">9.安装内核</h3><p>【<strong>终端</strong>】输入 <strong>sudo make install</strong> <imgsrc="https://img-blog.csdnimg.cn/2d25ee4d175b4a82a82daa593eb44192.png#pic_center"alt="在这里插入图片描述" /></p><h3 id="重启系统">10.重启系统</h3><p><imgsrc="https://img-blog.csdnimg.cn/20200625150529871.jpg#pic_center"alt="在这里插入图片描述" />重启过后，内核是自动选择刚编译的新内核，如果不是，则在重启过程中，按下shift键后，手动选择一下即可。</p><h3 id="1">11.可能的错误</h3><p><strong>错误1</strong></p><figure><imgsrc="https://img-blog.csdnimg.cn/48bd70672d2d4fab8ca44fc09790699d.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>从错误信息可以看出，问题出在 debian/canonical-certs.pem上面。首先，用vim打开内核的配置文件.config， <imgsrc="https://img-blog.csdnimg.cn/ec2c35e172a545e4a1869ff989da95d6.png#pic_center"alt="在这里插入图片描述" />然后找到”debian/canonical-certs.pem“所在的位置，将其引号内容置空。这是原始文件内容。 <imgsrc="https://img-blog.csdnimg.cn/568df85e6b8f48e0bdfa8a1676e761ed.png#pic_center"alt="在这里插入图片描述" /> 这是修改后的文件内容。 <imgsrc="https://img-blog.csdnimg.cn/82e15d0200fc40668c461b842f323426.png#pic_center"alt="在这里插入图片描述" /></p><hr /><h2 id="三实验测试">三、实验测试</h2><p>  这部分是最激动人心的环节，它决定着你的努力，你的时间是否得到了回报，究竟是回报的迟到还是失败的重现？下面就跟着博主来见证一下啦！  首先，查看一下内核版本是否为新安装的内核版本，然后再去编写程序验证程序的系统调用函数的正确性。</p><p>【<strong>终端</strong>】输入 <strong>uname -r</strong>，查看内核版本</p><p><imgsrc="https://img-blog.csdnimg.cn/20200625155327207.jpg#pic_center"alt="在这里插入图片描述" />从返回结果可以看出，已经成功安装了新内核，但系统调用是否有用，还得用程序验证一下：</p><p>（1）安装 gcc 在【<strong>终端</strong>】中输入 <strong>apt-get -yinstall gcc</strong></p><p>（2）编写测试程序 test.c 在【<strong>终端</strong>】中键入<strong>vim test.c</strong> ,此时新建了一个 ==test.c==的c文件，在文件输入以下内容：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> a=syscall(<span class="number">439</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the result is %ld.\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://img-blog.csdnimg.cn/20200625151245144.jpg#pic_center"alt="在这里插入图片描述" />保存后退出，在【<strong>终端</strong>】中依次执行 <strong>gcc test.c -otest.out</strong> 、<strong>./test.out</strong></p><p><imgsrc="https://img-blog.csdnimg.cn/20200625151513486.jpg#pic_center"alt="在这里插入图片描述" /> 由 result is 64.，可以看出，内核编译是成功了！！！</p><h2 id="四可能的错误">四、可能的错误</h2><p>  在实验过程中，出现了太多的错误，大多是因为没有安装一些相应的依赖包，以及系统调用函数的书写错误而导致，那都是博主的辛酸史，没有必要记录下来，读者们只需要按照上述步骤依次执行，就可以成功完成实验。  在重启系统时，出现了下图错误（忘记截图了，从网上盗了一张），尝试了挺多的办法，最后从一博文中看到，修改虚拟机内存大小即可解决该问题，博主原先的是2GB，后来修改为4GB，果断解决了问题，成功进入新内核的Ubuntu系统。</p><figure><img src="https://img-blog.csdnimg.cn/20200625151851821.jpg#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="五总结">五、总结</h2><p>  很是欣赏专业老师的一句话，大抵是说，只有经过一段痛苦的折磨，才能够有所成长。的确，这两天不断在改内核，编译内核，其间不知翻了多少次车，一个个可能的错误不停地排除，浪费的时间主要是在内核编译上，一次修改后的重新编译差不多就是一小时，一天又有几个一小时呢？  通过这次实验，对Linux系统的内核了解了一点，可能连皮毛也不算，但较之之前的一无所知，博主心中已是知足，在修改内核过程中，对vim的操作以及Linux的一些常规命令也更加熟悉了，相比之下，这才是我收获最大的地方，毕竟，从事IT行业，Linux是基础。</p><hr /><p>PS:</p><ul><li>注意本篇博文是在Ubuntu20.04的基础上来写的，所有步骤在其上均可通过，博主又测试了Ubuntu18.04，也可通过，但并不保证在所有的Linux系统上均可以无错误地通过；</li><li>留给虚拟机的磁盘尽量大点，建议50GB起，磁盘空间不够也会引发未知错误；</li><li>实验验证前面内容（内核编译）于2023年6月重新修正</li><li>博文若有不妥的地方，欢迎读者们在评论区留言，博主一定改进；</li><li>本文为博主原创文章，若要转载，请注明出处。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言十大排序算法总结</title>
      <link href="/2024/03/13/C%E8%AF%AD%E8%A8%80%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/13/C%E8%AF%AD%E8%A8%80%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序">插入排序</h1><blockquote><p>基本思想是每次将一个待排序的记录按其关键字大小插入前面已经排好序的子序列，直到全部记录插入完成。</p></blockquote><h2 id="直接插入排序">1.直接插入排序</h2><h3 id="代码实现">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 依次将arr[1, ..., arrSize - 1]插入到前面已经排序好的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123; <span class="comment">// 若arr[i]小于前驱，需要将其插入前面已经排序好的子序列</span></span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="comment">// 从后往前查找待插入位置, 终止条件是，arr[j] &lt;= temp;</span></span><br><span class="line">            <span class="type">int</span>  j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">// 后移</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// arr[j] &lt;= temp; j + 1是插入位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析</h3><ul><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(n^2)\)</span>；<ul><li>向有序子表中逐个插入元素的操作进行了 <span class="math inline">\(n -1\)</span> 趟，每趟操作都分为比较关键字和移动元素。</li><li><strong>最好的情况</strong>是元素有序，此时每插入一个元素，都只需比较一次而不用移动元素，时间复杂度为$ O(n) $;</li><li><strong>最坏的情况</strong>是元素逆序，总的比较次数为 $(1 + 2 + 3 +··· + n - 1) $ ，总的移动次数为 <span class="math inline">\((1 + 2  +··· + n - 1 + 2)\)</span>;</li></ul></li><li><strong>空间复杂度：</strong>$ O(1)$；<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性</strong>：稳定<ul><li>由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况。</li></ul></li></ul><h2 id="折半插入排序">2.折半插入排序</h2><h3 id="代码实现-1">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与直接插入唯一不同在于查找插入位置时是使用折半查找</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 依次将arr[1, ..., arrSize - 1]插入到前面已经排序好的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i]; <span class="comment">// 将当前元素保存</span></span><br><span class="line">        <span class="comment">// 在前面子序列中折半查找插入位置</span></span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; arr[mid]) <span class="comment">//查左半子表</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 查右半子表</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// low是插入位置, 或者high + 1;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= low; --j) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1">复杂度分析</h3><ul><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(n^2)\)</span>；<ul><li>折半插入排序仅减少了比较元素的次数，比较次数约为 <spanclass="math inline">\((nlog_2 n)\)</span></li><li>比较次数与待排序表的初始状态无关，仅取决于表中的元素个数 <spanclass="math inline">\(n\)</span>;</li></ul></li><li><strong>空间复杂度：</strong>$ O(1)$；<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性</strong>：稳定</li></ul><h2 id="希尔排序">3.希尔排序</h2><blockquote><p>先将待排序表分割成若干形如 $ L[i, i + d, i + 2d, ··· , i + kd]$ 的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。</p></blockquote><h3 id="代码实现-2">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// d1 = n / 2, d(i + 1) = d1 / 2;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> dk = arrSize / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk /= <span class="number">2</span>) &#123; <span class="comment">// 可以将dk理解为步长，dk = 1时，退化为直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = dk; i &lt; arrSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i - dk]) &#123; <span class="comment">// 需要将 arr[i] 插入有序增量子表中</span></span><br><span class="line">                <span class="type">int</span> temp = arr[i];</span><br><span class="line">                <span class="type">int</span> j = i - dk;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                    arr[j + dk] = arr[j];</span><br><span class="line">                    j -= dk;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 退出循环后，arr[j] &lt;= temp, 显然 j + dk 是插入位置</span></span><br><span class="line">                arr[j + dk] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2">复杂度分析</h3><ul><li><strong>时间复杂度：</strong><ul><li>希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难</li><li>当 <span class="math inline">\(n\)</span>在某个特定范围内，希尔排序的时间复杂度约为 <spanclass="math inline">\(O(n^{1.3})\)</span>;</li><li>最坏情况下希尔排序的时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span>;</li></ul></li><li><strong>空间复杂度：</strong><spanclass="math inline">\(O(1)\)</span>;<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性：</strong>不稳定<ul><li>当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序。</li></ul></li></ul><h1 id="交换排序">交换排序</h1><blockquote><p>所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。</p></blockquote><h2 id="冒泡排序">4.冒泡排序</h2><h3 id="代码实现-3">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本思想：从前往后两两比较相邻元素的值，若为逆序，则交换他们，直到序列比较完</span></span><br><span class="line"><span class="comment">// 上述是第一趟冒泡，结果是将最大的元素交换到最后一个</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize - <span class="number">1</span>; i++) &#123; <span class="comment">// 无须和自己比较，所以趟数为 arrSize - 1;</span></span><br><span class="line">        <span class="type">int</span> swapflag = <span class="number">0</span>;<span class="comment">// 表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arrSize - <span class="number">1</span> - i; j++) &#123; <span class="comment">// arrSize - 1 - i 是因为每一趟就会少一个</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">/* 交换 */</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                swapflag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本趟遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (swapflag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后往前</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort2</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> swapflag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// j 从后往前，第i趟说明第i个元素确定好顺序了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arrSize - <span class="number">1</span>; j &gt; i; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">/* 交换 */</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                swapflag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (swapflag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3">复杂度分析</h3><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(n^2)\)</span>;<ul><li>最好情况下时间复杂度为 <span class="math inline">\(O(n)\)</span>;<ul><li>初始序列有序，第一趟冒泡排序后直接跳出循环。此时比较次数为 <spanclass="math inline">\(n - 1\)</span>，移动次数为 <spanclass="math inline">\(0\)</span>;</li></ul></li><li>最坏情况下时间复杂度为 <span class="math inline">\(O(n^2)\)</span> ;<ul><li>初始序列逆序，要进行 <span class="math inline">\((n - 1)\)</span>趟冒泡。第 <span class="math inline">\(i\)</span> 趟要进行 <spanclass="math inline">\(n - i\)</span> 次比较，移动次数为 <spanclass="math inline">\(3(n - i)\)</span> ;</li></ul></li></ul></li><li><strong>空间复杂度：</strong> <spanclass="math inline">\(O(1)\)</span>;<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性：</strong>稳定</li></ul><h2 id="快速排序">5.快速排序</h2><h3 id="代码实现-4">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 假设枢轴元素为第一个</span></span><br><span class="line">    <span class="type">int</span> pivot = arr[low];</span><br><span class="line">    <span class="comment">// 高低指针向中心靠拢</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 高指针寻找第一个比枢轴元素小的</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--;</span><br><span class="line">        arr[low] = arr[high];   <span class="comment">// 将其移动至arr[low]</span></span><br><span class="line">        <span class="comment">// 低指针寻找第一个比枢轴元素大的</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++;</span><br><span class="line">        arr[high] = arr[low];   <span class="comment">// 将其移动至arr[high]</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="comment">// 返回的是确定位置的元素下标  </span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件 </span></span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 确定位置的元素下标 </span></span><br><span class="line">    <span class="type">int</span> mid = partition(arr, low, high);</span><br><span class="line">    <span class="comment">// 左边递归排序 </span></span><br><span class="line">    quickSort(arr, low, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 右边递归排序 </span></span><br><span class="line">    quickSort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-4">复杂度分析</h3><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(log_2n)\)</span>;<ul><li>快速排序的运行时间与划分是否对称有关。</li><li>最坏情况：<span class="math inline">\(O(n^2)\)</span>;<ul><li>两个区域分别包括 <span class="math inline">\(n - 1\)</span> 和 <spanclass="math inline">\(0\)</span> 个元素时，即序列开始时便逆序</li></ul></li><li>最好情况：<span class="math inline">\(O(nlog_2n)\)</span>;<ul><li>尽可能地划分两个左右序列</li></ul></li></ul></li><li><strong>空间复杂度：</strong><spanclass="math inline">\(O(nlog_2n)\)</span>;<ul><li>由于快排是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大深度一致</li><li>最好的情况：<span class="math inline">\(O(log_2n)\)</span>;</li><li>最坏的情况：<span class="math inline">\(O(n)\)</span>;<ul><li>因为要进行 <span class="math inline">\(n - 1\)</span>次递归调用</li></ul></li></ul></li><li><strong>算法稳定性：</strong>不稳定<ul><li>在划分算法中，若右端区间有两个关键字相同，且均小于枢轴元素，则在交换到左端区间后，它们的相对位置会发生变化</li></ul></li></ul><h1 id="选择排序">选择排序</h1><blockquote><p>选择排序的基本思想是：每一趟（如第 <spanclass="math inline">\(i\)</span> 趟）在后面 <spanclass="math inline">\(n - i + 1(i = 1, 2, ··· ,n - 1)\)</span>个待排序元素中选取关键字最小的元素，作为有序子序列的第 <spanclass="math inline">\(i\)</span> 个元素，直到第 <spanclass="math inline">\(n - 1\)</span>趟排序做完，待排序元素只剩下1个，就不再选了。</p></blockquote><h2 id="简单选择排序">6.简单选择排序</h2><h3 id="代码实现-5">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法思想：假设排序表为L[1,...,n]，第i趟排序即从L[i,..,n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置</span></span><br><span class="line"><span class="comment">// 这样经过 n - 1趟排序就可以使得整个排序表有序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arrSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// minIndex 为最小元素下标</span></span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-5">复杂度分析</h3><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(n^2)\)</span>;<ul><li>主要分为比较次数和移动次数</li><li>最坏情况下，比较次数为<span class="math inline">\((1 + 2 + ··· + n -1)\)</span>, 移动次数为<span class="math inline">\(3(n -1)\)</span>;</li><li>最好情况下，比较次数为<span class="math inline">\((1 + 2 + ··· + n -1)\)</span>, 移动次数为 <span class="math inline">\(0\)</span>;</li></ul></li><li><strong>空间复杂度：</strong> <spanclass="math inline">\(O(1)\)</span>;<ul><li>仅使用常数个辅助单元</li></ul></li><li><strong>算法稳定性：</strong>不稳定<ul><li>{2，<strong>2</strong>， 1} 经过一趟排序后变为{1，<strong>2</strong>， 2};</li></ul></li></ul><h2 id="堆排序">7.堆排序</h2><h3 id="代码实现-6">代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先将元素建成大根堆，此时堆顶元素就是最大值。</span></span><br><span class="line"><span class="comment"> * 输出堆顶元素后，通常将堆底元素送入堆顶，此时根节点不满足大根堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大根堆的性质。</span></span><br><span class="line"><span class="comment"> * 再输出堆顶元素，如此重复，直至堆中仅剩下一个元素为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整以k为根节点的堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjustDown</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 先将根节点的值保存一下 </span></span><br><span class="line">    <span class="type">int</span> tmp = arr[k];</span><br><span class="line">    <span class="comment">// 2 * k + 1: k节点的左节点</span></span><br><span class="line">    <span class="comment">// 2 * k + 2: k节点的右节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * k + <span class="number">1</span>; i &lt; arrSize; i = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// i + 1 &lt; arrSize 确保右节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; arrSize &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>]) <span class="comment">// 左子节点 &lt; 右子节点</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">// i始终指向值最大的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= arr[i]) <span class="comment">// k节点值 &gt;= 子节点，满足大根堆性质</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            arr[k] = arr[i];</span><br><span class="line">            k = i; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[k] = tmp;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/* 建立小跟堆 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 最后一个父节点 </span></span><br><span class="line">    <span class="comment">// arrSize为元素个数, -1 是因为下标从0开始</span></span><br><span class="line">    <span class="type">int</span> i = arrSize / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjustDown(arr, arrSize, i); <span class="comment">// 调整以i为父节点的堆</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapsort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 建立大根堆</span></span><br><span class="line">    buildMaxHeap(arr, arrSize);</span><br><span class="line">    <span class="comment">// 2. 从最后一个元素开始，与堆顶元素进行交换，直到只剩下一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[<span class="number">0</span>]; </span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="comment">// 交换完成，调整大根堆，此时堆的长度为i</span></span><br><span class="line">        adjustDown(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="复杂度分析-6">复杂度分析</h3><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(nlog_2n)\)</span>;<ul><li>分为建立大根堆和调整堆<ul><li>在建n个元素的堆时，时间复杂度为 <spanclass="math inline">\(O(n)\)</span>;</li><li>需要进行 <span class="math inline">\(n - 1\)</span>次堆调整，每次调整的时间复杂度为 <spanclass="math inline">\(O(h)\)</span></li></ul></li></ul></li><li><strong>空间复杂度：</strong><spanclass="math inline">\(O(1)\)</span>;<ul><li>仅使用了常数个辅助单元</li></ul></li><li><strong>算法稳定性：</strong>不稳定</li></ul><h1 id="归并排序">8.归并排序</h1><h2 id="代码实现-7">代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假定待排序表含有n个记录，则可将其视为n个有序的子表，每个子表的长度为1，然后两两归并，等到 n/2(向上取整) 个长度为2或1的有序表；</span></span><br><span class="line"><span class="comment"> * 继续两两归并······</span></span><br><span class="line"><span class="comment"> * 如此重复，直至合并成一个长度为n的有序表为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将前后相邻的两个有序表归并为一个有序表</span></span><br><span class="line"><span class="comment">// arr[low, mid], arr[mid + 1, high];</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 开辟一个临时数组，tmp[low, high]</span></span><br><span class="line">    <span class="type">int</span> *tmp = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (high - low + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">// tmp[]的下标</span></span><br><span class="line">    <span class="comment">// 从两个有序表第一个元素开始往后遍历，将小元素放入tmp中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前面有序表未放完</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = arr[i++];</span><br><span class="line">    <span class="comment">// 后面有序表未放完</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        tmp[k++] = arr[j++];</span><br><span class="line">    <span class="comment">// 将tmp元素赋值到arr中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        arr[low + i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mergesort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    mergesort(arr, left, mid);</span><br><span class="line">    mergesort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(arr, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-7">复杂度分析</h2><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(nlog_2n)\)</span><ul><li>每趟归并的时间复杂度为 <spanclass="math inline">\(O(n)\)</span>，需要进行 <spanclass="math inline">\(log_2n(向上取整)\)</span> 趟归并</li></ul></li><li><strong>空间复杂度：</strong> <spanclass="math inline">\(O(n)\)</span>;<ul><li>merge()操作中，辅助空间刚好为<spanclass="math inline">\(n\)</span>个单元</li></ul></li><li><strong>算法稳定性：</strong> 稳定</li></ul><h1 id="计数排序">9. 计数排序</h1><blockquote><p>主要思想：开辟一个长为 maxVal - minVal +1的计数数组，然后遍历一遍原数组，将元素值-minVal作为计数数组的索引，值则自增。</p><p>此时计数数组中不为0的元素值为原数组中元素值等于索引的个数。遍历计数数组，遇到不为0的元素，反写回原数组。</p></blockquote><h2 id="代码实现-8">代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不稳定法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化最大值和最小值为首元素</span></span><br><span class="line">    <span class="type">int</span> maxVal = arr[<span class="number">0</span>], minVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxVal)</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; minVal)</span><br><span class="line">            minVal = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 maxVal, minVal分别为最大值和最小值</span></span><br><span class="line">    <span class="comment">// 创建一个计数数组, 长度为maxVal - minVal + 1;</span></span><br><span class="line">    <span class="type">int</span> countArrSize = maxVal - minVal + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *countArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (countArrSize));</span><br><span class="line">    <span class="comment">// 将计数数组初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; countArrSize; i++)</span><br><span class="line">        countArr[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将原数组中的值减去最小值，将其作为索引，存入计数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        countArr[arr[i] - minVal]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历计数数组，根据元素个数还原</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; countArrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (countArr[i]) &#123; <span class="comment">// count数组中还有计数</span></span><br><span class="line">            arr[j++] = i + minVal; <span class="comment">// 要加上最小值，还原    </span></span><br><span class="line">            countArr[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(countArr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 稳定法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countSort2</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取排序数组的最大元素</span></span><br><span class="line">    <span class="type">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取排序数组的最小元素</span></span><br><span class="line">    <span class="type">int</span> minVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxVal)</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; minVal)</span><br><span class="line">            minVal = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数数组的长度</span></span><br><span class="line">    <span class="type">int</span> countArrSize = maxVal - minVal + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建一个计数数组</span></span><br><span class="line">    <span class="type">int</span> *countArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * countArrSize);</span><br><span class="line">    <span class="comment">// 初始化为0</span></span><br><span class="line">    <span class="built_in">memset</span>(countArr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * countArrSize);</span><br><span class="line">    <span class="comment">// 计数, 统计每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        countArr[arr[i] - minVal]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累计计数，计算每个元素在排序后数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; countArrSize; i++) &#123;</span><br><span class="line">        countArr[i] += countArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序：根据累计计数数组将元素放置到正确的位置</span></span><br><span class="line">    <span class="type">int</span> *result = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * arrSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        result[countArr[arr[i] - minVal] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        countArr[arr[i] - minVal]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制到原空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-8">复杂度分析</h2><ul><li><strong>时间复杂度：</strong> $O(n + k) <spanclass="math inline">\(，\)</span>k$ 为整数范围<ul><li>最后的两层循环，最外层执行的次数为 <spanclass="math inline">\(k\)</span>, 最里层最终次数为<spanclass="math inline">\(n\)</span>, 因此总的次数是 <spanclass="math inline">\(n + k\)</span>;</li></ul></li><li><strong>空间复杂度：</strong><ul><li><span class="math inline">\(O(k)\)</span>，<spanclass="math inline">\(k\)</span>​ 为整数范围（不稳定算法）</li><li><span class="math inline">\(O(k + n)\)</span>, （稳定算法）</li></ul></li><li><strong>算法稳定性：</strong>稳定 / 不稳定</li></ul><h1 id="桶排序">10. 桶排序</h1><blockquote><p>主要思想就是：将要排序的数据分到几个有序的桶里，每个桶里的元素再单独进行排序。桶内排序完之后，再把每个桶里面的数据按照顺序依次取出，组成的序列就是排好序的序列。</p><p>要先确定好桶的个数和映射函数</p></blockquote><h2 id="代码实现-9">代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义桶的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 桶中元素个数</span></span><br><span class="line">    <span class="type">int</span>* values;    <span class="comment">// 桶中数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 桶排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bucketCount = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 创建桶数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> <span class="title">buckets</span>[<span class="title">bucketCount</span>];</span>   </span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        buckets[i].count = <span class="number">0</span>;</span><br><span class="line">        buckets[i].values = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据分散到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="type">int</span> bucketIndex = <span class="built_in">array</span>[i] / bucketCount;</span><br><span class="line">        buckets[bucketIndex].values[buckets[bucketIndex].count++] = <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 对每个桶中的数据进行排序</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (buckets[i].count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">// 使用简单的冒泡排序，实际中可以使用其他更高效的排序算法</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; buckets[i].count - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; buckets[i].count - j - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (buckets[i].values[k] &gt; buckets[i].values[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                         <span class="comment">// 交换桶中的元素</span></span><br><span class="line">                         <span class="type">int</span> temp = buckets[i].values[k];</span><br><span class="line">                         buckets[i].values[k] = buckets[i].values[k + <span class="number">1</span>];</span><br><span class="line">                         buckets[i].values[k + <span class="number">1</span>] = temp;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 合并所有桶的结果</span></span><br><span class="line">     <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; buckets[i].count; j++) &#123;</span><br><span class="line">             <span class="built_in">array</span>[index++] = buckets[i].values[j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 释放桶内存</span></span><br><span class="line">         <span class="built_in">free</span>(buckets[i].values);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-9">复杂度分析</h2><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(n)\)</span>​<ul><li>在均匀分布情况下，桶排序的平均时间复杂度接近线性</li></ul></li><li><strong>空间复杂度</strong>：较高，具体取决于桶的数量和分配的空间</li><li><strong>算法稳定性：</strong>取决于桶内排序的稳定性</li><li>桶排序仅适用于元素数据分布相对均匀且元素范围较小。</li></ul><h1 id="基数排序">11.基数排序</h1><blockquote><p>主要思想是：第一趟排序的基数为1，即根据个位数放入相应的桶中，然后再将按桶号将桶中元素分别放回原数组，完成一趟排序，此时个位数已经有序</p><p>第二趟排序的基数为10，即根据10位数放入相应的桶中，重复以上过程。</p><p>趟数为最大元素的数字个数。</p></blockquote><h2 id="代码实现-10">代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义十个桶 0...9</span></span><br><span class="line">    <span class="type">int</span> bucket[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// result 是答案数组</span></span><br><span class="line">    <span class="type">int</span> *result = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * arrSize);</span><br><span class="line">    <span class="comment">/* 1.求数组中最大元素 */</span></span><br><span class="line">    <span class="type">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxVal)</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 2.求最大元素数字个数 */</span></span><br><span class="line">    <span class="type">int</span> maxValCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxVal) &#123;</span><br><span class="line">        maxValCount += <span class="number">1</span>;</span><br><span class="line">        maxVal /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="type">int</span> base = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; maxValCount; k++) &#123;</span><br><span class="line">         <span class="comment">// 求每一个元素的base上数字，放入对应的桶里面</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">             bucket[(arr[i] / base) % <span class="number">10</span>]++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 计算累加和</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 根据桶数组，将元素放入原先数组中</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">             result[bucket[(arr[i] / base) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">             bucket[(arr[i] / base) % <span class="number">10</span>]--;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 将result数组元素复制到arr中，循环</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">             arr[i] = result[i];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 清空桶元素</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             bucket[i] = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// base乘以10，进入下一趟排序</span></span><br><span class="line">         base *= <span class="number">10</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-10">复杂度分析</h2><ul><li><strong>时间复杂度：</strong> <span class="math inline">\(O(d(n +r)\)</span><ul><li><span class="math inline">\(d\)</span> ——最大数字的位数，即循环的次数</li><li><span class="math inline">\(r\)</span> ——数字的基数，表明桶的个数</li></ul></li><li><strong>空间复杂度</strong>：<span class="math inline">\(O(n +r)\)</span></li><li><strong>算法稳定性：</strong>稳定</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 C 排序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Socket编程</title>
      <link href="/2023/10/01/Linux-Socket%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/10/01/Linux-Socket%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>linux c socket</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/30/hello-world/"/>
      <url>/2023/09/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
